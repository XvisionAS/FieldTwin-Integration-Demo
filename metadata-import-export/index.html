<!DOCTYPE html>
<html>

<head>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
    integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.16.1/xlsx.core.min.js"></script>
</head>

<body>
  <div id="app" class="continer-fluid m-3">
    <h3 v-if="message">{{ message }}</h3>
    <div class="card mt-3" v-if="selected.id">
      <div class="card-body">
        <ul class="list-group list-group-flush" v-if="!metaData.length">
          <li class="list-group-item">
            This object has no metadata.
          </li>
        </ul>
        <ul class="list-group list-group-flush" v-if="metaData.length">
          <li class="list-group-item pb-3">
            <p>Click to export the selected object's metadata to an Excel file</p>
            <button class="btn btn-primary" @click="DownloadMetaData">Download Metadata</button>
          </li>
          <li class="list-group-item">
            <p>
              This section allows you to upload an Excel file containing object metadata
              and (step 1) compare the uploaded values with the existing values then (step 2)
              apply the values from the Excel file in FieldTwin.
            </p>
            <input type="file" ref="fileInput" @change="uploadFile" />
            <div class="mt-2">
              <button class="btn btn-primary" @click="compareMetaData">Compare Metadata</button>
              <button class="btn btn-success" @click="uploadMetaData" v-if="comparisonResults.length">Store Metadata</button>
            </div>
            <div class="table-responsive" v-if="comparisonResults.length">
              <table class="table mt-3">
                <thead>
                  <tr>
                    <th>Match</th>
                    <th>Existing Metadata</th>
                    <th>Uploaded Metadata</th>
                  </tr>
                </thead>
                <tbody>
                  <tr v-for="result in comparisonResults" :class="{ 'table-danger': !result.match }">
                    <td>{{ result.match }}</td>
                    <td>{{ result.value1 }}</td>
                    <td>{{ result.value2 }}</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <script>
    const app = new Vue({
      el: "#app",
      data: {
        message: "Initialising...",
        token: '',
        backendUrl: '',
        projectId: '',
        subProject: '',
        selected: { id: null },
        metaData: [],
        comparisonResults: []
      },
      methods: {
        reset() {
          this.selected = { id: null };
          this.metaData = [];
          this.comparisonResults = [];
          this.clearUploadFile();
        },
        uploadFile() {
          this.file = this.$refs.fileInput.files[0];
        },
        clearUploadFile() {
          this.$refs.fileInput.value = '';
        },
        DownloadMetaData() {
          const workbook = XLSX.utils.book_new();
          const worksheet = XLSX.utils.json_to_sheet(this.metaData);
          XLSX.utils.book_append_sheet(workbook, worksheet, "Data");
          const filename = this.selected.id + ".xlsx";
          XLSX.writeFile(workbook, filename);
          this.message = "Data exported to " + filename;
        },
        compareMetaData() {
          this.comparisonResults = [];
          const reader = new FileReader();
          reader.onload = e => {

            // Read uploaded file
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: "array" });
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];
            const uploadedJSON = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

            // Load metaData into SheetJS
            const workbook2 = XLSX.utils.book_new();
            const worksheet2 = XLSX.utils.json_to_sheet(this.metaData);
            XLSX.utils.book_append_sheet(workbook2, worksheet2, "Data");
            const metaData = XLSX.utils.sheet_to_json(worksheet2, { header: 1 });

            for (let i = 0; i < Math.max(metaData.length, uploadedJSON.length); i++) {
              const rowNumber = i + 1;
              let match = false;
              let value1 = metaData[i];
              let value2 = uploadedJSON[i];
              if (value1 === undefined) {
                value1 = '';
              } else if (value2 === undefined) {
                value2 = '';
              } else {
                match = JSON.stringify(value1) === JSON.stringify(value2);
              }
              this.comparisonResults.push({ rowNumber, value1, value2, match });
            }
          };
          reader.readAsArrayBuffer(this.file);
        },
        uploadMetaData() {
          const reader = new FileReader();
          reader.onload = e => {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: "array" });
            const worksheet = workbook.Sheets[workbook.SheetNames[0]];
            const uploadedJSON = XLSX.utils.sheet_to_json(worksheet);
            fetch(`${this.backendUrl}/API/v1.9/${this.projectId}/subProject/${this.subProjectId}/${this.selected.type}/${this.selected.id}`, {
              method: 'PATCH',
              headers: { 'Authorization': 'Bearer ' + this.token, 'Content-Type': 'application/json' },
              body: JSON.stringify({ metaData: uploadedJSON })
            })
              .then(response => response.json())
              .then(data => {
                this.message = `Stored ${this.selected.type} metadata on ${this.selected.id}`
                this.reset()
              })
              .catch(error => {
                console.error('Error:', error);
              });
          }
          reader.readAsArrayBuffer(this.file);
        },
        filterMetadataKeys(mdArray) {
          return mdArray.map(md => {
            const obj = {...md}
            delete obj.id
            delete obj.metaDatumLinkId
            delete obj.definitionId
            delete obj.vendorId
            delete obj.tags
            delete obj.cost
            delete obj.costObject
            delete obj.costPerLength
            delete obj.unit
            delete obj.vendorAttributes
            return obj
          });
        }
      }
    });

    const appReset = app.reset.bind(app)

    function onWindowMessage(event) {
      switch (event.data.event) {
        case 'loaded':
        case 'tokenRefresh':
          app.message = 'Select an object...'
          app.token = event.data.token
          app.backendUrl = event.data.backendUrl
          app.projectId = event.data.project
          app.subProjectId = event.data.subProject
          break
        case 'select':
          if (event.data.data.length && ["connection", "stagedAsset", "well"].includes(event.data.data[0].type)) {
            app.selected = {
              id: event.data.data[0].id,
              type: event.data.data[0].type
            }
            fetch(`${app.backendUrl}/API/v1.9/${app.projectId}/subProject/${app.subProjectId}/${app.selected.type}/${app.selected.id}`, {
              headers: { 'Authorization': 'Bearer ' + app.token }
            })
              .then(response => response.json())
              .then(data => {
                app.metaData = app.filterMetadataKeys(data.metaData || [])
                app.message = `Selected: ${app.selected.type} ${app.selected.id}`
              })
              .catch(error => {
                console.error('Error:', error);
              });
          } else {
            appReset()
            app.message = 'Select an object...'
          }
          break
        case 'unselect':
          appReset()
          app.message = 'Select an object...'
          break
      }
    }
    window.addEventListener("message", onWindowMessage);
  </script>
</body>

</html>